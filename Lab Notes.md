Materialism
	- It is hard to consider oneself an expert user of contemporary OS. Differently from other skills, the use of IT does not automatically lead to knowledge.
	- Computer - originally giant machine in an office; a shared environment.
	- A terminal is the accessible part of a machine - its interface. Not all modern machines have a terminal.
	- Collective computers are no longer common. But an idea of collective computing persists - and is actually returning - through the concept of cloud.
	- Our personal terminals mirror those of the 70s and 80s.
	- A terminal application emulates the actual terminal.
	- The set of commands that I send to a terminal are part of a batch (? bash). Those are available to each terminal every time.
	- My terminal is emulating the traditional terminal. It is emulating an access to a different machine.
	- Unix and unix derivatives. Unix OS are special ways of accessing a machine. Unix systems are bound together by a general philosophy of computing; there are parts of this philosophy in both Mac and, of course, Android systems.
	- These ways of accessing and manipulating data have been under development since the 80s; they will probably still be used for a very long time.
	- The advantage of Unix based systems is their durability: the code used is Plaintext - readable by humans - and their source code is open.
	- The most essential operations happening in a machine are processed through a binary code; but with Unix, the closest level to this binary - nonhuman - language is a code that we can understand.
	- Unix is longlasting and human friendly. It has to be readable.
	- Interface - have a look at MS Word: some of the buttons and the commands are unknown to most users; besides, its interface will always be significantly different from that of another program. In Unix based systems, the interface is uniform across different softwares. The idea is that of having many small programs that all look and do the same.
	- It is important to consider the potential complexity of any software that we are using.

- - - - - - - - - -

Practice from the Terminal.

	- pwd: gives you the position of where you currently are. The directory where you currently are.
	-  the / indicates the root position.
	- ls: lists the contents of the current directory.
	- mkdir:  creates a new directory.
	- man [+ command]: gives you instructions about the command that you are interested in. "man" stands for "manual". It originally was an actual paper manual.
	- clear: it clears the prompt.
	- cd: change directory.
	- cd ..: leave current directory - move to the above directory.
	- cd -: go to the previous directory.
	- pushd: pushes a stack of directories (?).
	- popd: pops a stack of directories (?).
		- Baboun has built a Unix partition within my Windows system. I have no way of accessing my standard Windows partition from this terminal.
		- The structure of Unix partitions is the same across different Unix systems (from Debian to Android).
	- cd ~: automatically brings you to the "home" directory. There is always one.
		- "bin" is the directory containing all of the basic Unix commands - the small programs that make the entire system words.
		- All Unix commands have a syntax. Usually it is:
			[Verb] - [Adverb] - [Object]
			- The [Verb] is the command itself.
			- The [Adverb] is a modifier for the command.
			- The [Object] is, of course, the destination of the command.
			- Everything in Unix has a path. Any command - [Verb] - actually operates on a path.
	- ls .: the "point" means "execute this command HERE"; it is useful whenever a command asks for an explicit path as an object. In most cases it is not useful.
	- "find" "grab" "send" & "?": are incredibly sophisticated tools to search through my machine.
- Unix has a bias towards plain text data. Plaintext data is portable and sustainable. It will probably last for long and it will always be readable. By humans even. Well, maybe not really. But it certainly does not require a proprietary software in order to be decyphered.
- Plaintext is incredibly easy to process. Data mining and copying are definitely more feasible within a plaintext archive.
	- Learn to use "TAB"! Whenever you type the first two or three characters of a command, an autocomplete integrated system will automatically determine whether the command I am trying to use exists or not.
	- Remember that the entire Unix environment is strictly case sensitive.
	- cat: "concatenate files and print on the standard ouptut".
		- Levels of encryption.

-----------------------------------------------------------------------------------

Week 2

Text - Author - Code -> and then, citizenship
Tactile perception of textuality. Just so that we don't fall for the illusion that textuality is all the same.
Implications beyond any choice - what tool am I going to use? Individual - practical - and collective - political! - implications.
Beyond individual and political, our choices might even have PHENOMENOLOGICAL implications - remember Heidegger.
How are electronic instruments types of ENFRAMING? Zuhandichkeit - Heidegger's word for how handling is structuring?

Problem - how to organize stuff? Organizing my own private files has repercussions onto an editorial level. Production of knowledge as a material problem. Production of knowledge as me sitting in front of this very screen - this white sheet, this set of fonts, this blinking bar indicating the end of the current sentence. This is, right now, influencing my production.

Text and documents are considered as finished products. We think of them as POINTS. Instead, we should start seeing them as VECTORS. Not a destination - not a finite, determined, immutable destination - but a direction, a vector - something that is moving ahead. In fact, we could think of ANY TEXT as a VECTOR - including Shakespeare, constantly pushed forward from the moment of its production to any future time that will know his works.

Of course! Consider also editorial concerns - philology in a traditional sense - and picture each stage of textual production - from the draft to each more or less legitimate edition, as part of a single draft. Shakespeare is a vector exactly as a pdf.

Now, try imagining each file within my computer as a vector:

an e-mail
----------------------------->

a term paper
----------------------------->

bibliography
----------------------------->

Each vector has a particular set of affordances (?); each can be researched through a specific system. How do I store, back up and share these items, these vectors? Besides research, there are levels such as encryption (?) and access. Companies like Google or Amazon take care of each vector for us: they handle research, encryption and back up for us.
Whenever we decide to prefer a specific format to any other - I.E., write my paper using Word - I am pushed along a technological path that excludes any other option.
These multiplication of mutually exclusive vectors creates a dispersal and an entanglement.
Dennis' proposal: you should try and have as many of these originating points together. For instance, what if I wanted to search through all of these vectors, but they had no common origin?
One option: to sacrifice all of my texts and possessions to a single proprietary system - such as Google. But this entails a risk.
Definition of a computer: it's a machine that can emulate any other machine (tractor, spaceship, [crusade?]).
Emulation of a crusade: if	crusade; then	millennium.
Files that are human readable. Files that are not human readable. Then simple binary code. What levels can I control? The most primitive level is, of course, hardware. If we had to control every single step, we should probably build computers ourselves - own any interaction at any level.
Potential - unification of the vectors, so that any operation could be possible among them.
What is the solution? The solution is probably to transform all our files into plaintext files. I there were no proprietary file formats, we would just have a collection of plaintext that are longlasting and free.
What is the originating point of my vector, than? It is probably this very moment - the production of a text.
Even though we might be forced to adhere to what departments and publishing companies ask from us, but we might still control at least the source text, so that it will remain flexible and under our control.
Is plaintext apolitical? What sort of question is that? It allows us to control what we are writing. Therefore, if you want, plaintext is the first step towards something that is political.
The "Espionage Act" of 1993 (?!) forbids the teaching of encryption without military authorization - it is a dangerous technology, a weapon. Turing, like many of his peers of the time, was working for the military authorities with the Enigma Project. Much of the technological developments of the second half of the century depended on this coalition between scientists and military forces - for instance, the Internet.
[Another digression: minimal computing; .pdfs can't really be read in Africa: it is a propretary format that requires a certain standard of software.]
Unification of our textual activities: the project for the next few sessions.
Dennis' brief idea about MS Word: it has too broad of an audience. As it tries to please everyone, it actually pleases nobody.
Now let us try addressing a fundamental aspect of what we are doing, of what we will keep doing - FORM and CONTENT. Is there such thing as pure CONTENT, though? Let us not digress again and linger on literary matters. FORM and CONTENT do exist in IT.
Word works through the combination - the constant combination - of FORM and CONTENT. What is being written is also, constantly, being formatted. What you see is what you get. Any information regarding the FORMAT is actually stored somewhere beyond my text - there is a different sheet of content hidden beyond my own. A secret content that is format, and that is often only understandable by the proprietary format that produced it (see, again, the quintessential example: MS Word).
We have the illusion of controlling typesetting whenever we write something in MS Word or any other WYSIWYG software - we are not. Typesetting is in most cases controlled by different software houses that are somewhere else. A publishing house would usually just strip the text from any sort of formatting that I applied to it, and reformat it with their own typesetting software.
The ENFRAMING of Mark-Up: have a look at HTML and understand how mark-up works. Combination: a semantic unit compared with a formal unit. HTML is concerned about the semantics of form. What is a paragraph, what is a title, what is emphasis - and so on. HTML only stores content, even that level of content that might actually influence form. But it does not say what will happen with fonts and visualization. That is stored within a .css.
Problem with XML: it is impossible to write a paper with HTML or XML - if we had to mark everything up, it would take us more time to write a paper than usual - we would eventually spend more time formatting than writing or conceiving what we are going to write.
How do we differentiate semantics from pure form? We have to be concerned with the meaning of what we are writing, not with its formatting. HTML, however, does not do that purely: it still includes purely formal elements (italics and bold) within a set of apparently semantic markers (paragraph, title, quote). In a way, the problem with this mixture is that we always what to control levels that hardly belong to the realm of sole content. HTML is gunky; it does not operate its distinction as beautifully as it should (semantics - style - content - form?); it is not truly human readable.
MARKDOWN was born precisely to solve these problems: to achieve a neat separation between form, content (and style), and to have a clean, readable file.
Markup has implications for both technology and politics.
MARKDOWN is an incredibly popular format right now.

--------- Week III ----------------

Think of data and data flows as vectors; then, think about the entirety of literary production and **life itself**(?) as the production of vectors - as vectors themselves.

Blogging ------------------->
		[Word Press - XML - XML Editor]

Academic writing ---------->
		[MS Word - Doc - .pdf]

Mail --------------------->
		[MS Outlook - ...]

Now, our goal is to concentrate the entirety of this production and place it within a single box; we will have a single format (which will be, if you want, plaintext), a single editor (we still have to choice) and complementary systems for publishing, backup and so on.

What about a single editor, then? It would amplify our possibilities of interaction/intervention on every aspect of our textual production.

Plaintext: why not markdown, then? It is a plaintext format, it is easy to use and it is truly versatile. Let us get started!

	*** Markdown as a FORMAT, independently from the editor ***

How to emphasize a text? With asterisks.

	*emphasis*

Or with two asterisks.

	**emphasis!**

How to write headings? With hashtags.

#Most important title#
##Important title#
###Least important title###

The extension for Markdown is **.md**. From now on, these notes will be written in *markdown*.

Here, when I TAB something I indicate that the text that I am writing has some sort of CODE quality. It is an environment where, all of a sudden, space and formatting visually matter.

	Here is a text under tab.

More Interesting features. Imagine I have to insert a note. Here^[1].

[1] Note: this is interesting stuff. The notes are not really working.

' code '

'''' code block that is related to code that I do not want to be different from what I am actually writing and how I am formatting it. '''

Let's put a Link here. [Deboscio.](www.ildeboscio.it).
` Hey this is a tick and this is important code that has to be preserved forever. `

` :D `

``` 
Welcome to the JUNGLE! SPACE IS STILL RELEVANT HERE!                          YOWZ.    Yawz. 
```

### A new section. About what you should be doing.

Please take some time to consider options for visualization and editing. Very fascinating stuff happening inside of this section that will start *NOW*.

` TICK `

```

Tick?

```

### Another section. PANDOC.

What does PANDOC do? It is a sort of conversion editor that translates your format into whatever format you want. **What?!** Is this true or even possible? It does it. It transforms any textual format into any other format. Give it a try. Become a *believer*.

- Please be aware of the fact that our new best friend, **Pandoc**, actually functions solely through a terminal interface. Textual commands will have to be learnt.

- YaML is a little block of code that Pandoc automatically adds to any text it produces or converts. It contains information such as the title of the document, its author, and the bibliography that it is using. It can be personalized in order to add any sort of additional indication that we might need (but asome coding skills will be required).

- Some practice with PANDOC will be required.

- `:browse confirm saveas
pandoc -so notes.pdf Lab_Notes.md
	- Variables: 
		- **s** stands for **smart**;
		- **o** stands for *now guess what I am using* (he does so according to the extension we have used for the source and **the target** file).
	- Order of SVO:
		- **target** first (notes.pdf);
		- **source** second (Lab_notes.md).

> An important note of wisdom from Dennis Tenen: there is no such thing as a pure file name. We are always using a complete path, then a file name. The path can be virtually omitted, but it is still there.

> An additional note of wisdom from Dennis Tenen: reasonable standard (reasonable default) is an essential part of the Linux philosophy.

> Third note of wisdom: command-line tools do one thing well. That is why they can just be evoked once, and their only true variables (commands, inputs) are the flags that I can add to the principal command.
